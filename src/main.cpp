/*----------------------------------------------------------------------------------------*/
/*                                                                                        */      
/*    Project:          IQ2 Clawbot Project                                               */
/*    Module:           main.cpp                                                          */
/*    Author:           VEX                                                               */
/*    Created:          Fri Aug 05 2022                                                   */
/*    Description:      This is an IQ2 python Clawbot project                             */
/*                                                                                        */      
/*    Configuration:    Clawbot Template (Individual Motors + Controller)                 */
/*                      Controller                                                        */
/*                      Left Motor in Port 1                                              */
/*                      Right Motor in Port 6                                             */
/*                      Claw Motor in Port 4                                              */
/*                      Arm Motor in Port 10                                              */
/*                                                                                        */      
/*----------------------------------------------------------------------------------------*/

// Include the IQ Library
// #include <iostream>
// #include <string>
#include "vex.h"


// Allows for easier use of the VEX Library
using namespace vex;

// Brain should be defined by default
brain Brain;

// Robot configuration code.
inertial BrainInertial = inertial();
// controller Controller = controller();
motor ClawMotor = motor(PORT9, false);
motor ArmMotor = motor(PORT4, true);
motor LeftDriveSmart = motor(PORT12, 1, false);
motor RightDriveSmart = motor(PORT7, 1, true);

// proximity sensors
distance DistanceSensor = distance(PORT1);

void calibrateDrivetrain() {
  wait(200, msec);
  Brain.Screen.print("Calibrating");
  Brain.Screen.newLine();
  Brain.Screen.print("Inertial");
  BrainInertial.calibrate();
  while (BrainInertial.isCalibrating()) {
    wait(25, msec);
  }

  // Clears the screen and returns the cursor to row 1, column 1.
  Brain.Screen.clearScreen();
  Brain.Screen.setCursor(1, 1);
}

// Helper function to safely get integer part of a float
int getIntPart(float f) {
    // Handle potential NaN or Inf values if necessary, though unlikely for sensors
    if (isnan(f) || isinf(f)) return 0;
    return (int)f;
}

// Helper function to safely get fractional part * scale (e.g., scale=100 for 2 decimal places)
int getFracPart(float f, int scale) {
    if (isnan(f) || isinf(f)) return 0;
    // Use fabsf for float absolute value
    return (int)fabsf((f - getIntPart(f)) * (float)scale);
}

#include "vex.h"    // Main header for VEX IQ devices
#include <stdio.h>  // Include standard input/output for printf
#include <math.h>   // Include for fabsf (float absolute value)

using namespace vex;

// --- IMPORTANT: Device Configuration ---
// Ensure devices are configured in VEXcode IQ's "Devices" panel.
// Names MUST match configuration (e.g., DistanceSensor, BumperA, GyroS).
// These objects are typically declared globally by VEXcode's graphical setup
// or need to be declared here if doing it manually.

// Example declarations (may be auto-generated by VEXcode IQ):
// brain Brain;
// controller Controller1 = controller();
// distance DistanceSensor = distance(PORT1);
// bumper BumperA = bumper(PORT2);
// gyro GyroS = gyro(PORT3);
// color ColorSensorL = color(PORT4);
// motor LeftMotor = motor(PORT5);
// touchled TouchLedR = touchled(PORT6);


// --- Helper Functions ---

// Helper function to safely get integer part of a float
int getIntPart(float f) {
    if (isnan(f) || isinf(f)) return 0; // Basic error check
    return (int)f;
}

// Helper function to safely get fractional part * scale
int getFracPart(float f, int scale) {
    if (isnan(f) || isinf(f)) return 0; // Basic error check
    // Use fabsf for float absolute value to handle negative inputs correctly
    return (int)fabsf((f - getIntPart(f)) * (float)scale);
}


// --- Data Gathering and JSON Printing Function ---
// Reads sensor data, processes it, and prints it as a JSON object.
void printSensorDataAsJson() {

    // --- 1. Read Sensor Values ---
    // Assumes sensor objects (DistanceSensor, BumperA, etc.) are accessible globally

    bool dist_found = DistanceSensor.isObjectDetected();
    float dist_mm_float = DistanceSensor.objectDistance(mm);

    bool bumper_pressed = BumperA.pressing();

    // Ensure Gyro is calibrated before use
    float gyro_heading_float = GyroS.heading(degrees); // 0-359.9
    float gyro_rate_float = GyroS.rate(dps);          // degrees per second

    int color_hue = ColorSensorL.hue();
    int color_brightness = ColorSensorL.brightness();
    bool color_near = ColorSensorL.isNearObject();

    bool touchled_pressed = TouchLedR.pressing();

    float motor_pos_deg_float = LeftMotor.position(degrees);
    float motor_vel_rpm_float = LeftMotor.velocity(rpm);

    int axisA_value = Controller1.AxisA.position();
    bool buttonX_pressed = Controller1.ButtonX.pressing();

    // --- 2. Prepare Values for JSON (Convert Floats/Bools) ---

    // Distance (2 decimal places)
    int dist_mm_int = getIntPart(dist_mm_float);
    int dist_mm_frac = getFracPart(dist_mm_float, 100);

    // Gyro Heading (1 decimal place)
    int gyro_heading_int = getIntPart(gyro_heading_float);
    int gyro_heading_frac = getFracPart(gyro_heading_float, 10);

    // Gyro Rate (1 decimal place)
    int gyro_rate_int = getIntPart(gyro_rate_float);
    int gyro_rate_frac = getFracPart(gyro_rate_float, 10);

    // Motor Position (1 decimal place)
    int motor_pos_deg_int = getIntPart(motor_pos_deg_float);
    int motor_pos_deg_frac = getFracPart(motor_pos_deg_float, 10);

     // Motor Velocity (1 decimal place)
    int motor_vel_rpm_int = getIntPart(motor_vel_rpm_float);
    int motor_vel_rpm_frac = getFracPart(motor_vel_rpm_float, 10);

    // --- 3. Print JSON Object ---
    printf("{\n"); // Start JSON object

    // Distance Sensor Data
    printf("  \"object_detected\": %s,\n", dist_found ? "true" : "false");
    if (dist_found) {
         printf("  \"distance_mm_int\": %d,\n", dist_mm_int);
         printf("  \"distance_mm_frac\": %02d,\n", dist_mm_frac); // Pad with zero if needed
    } else {
         printf("  \"distance_mm_int\": null,\n"); // Use null for no object
         printf("  \"distance_mm_frac\": null,\n");
    }

    // Bumper Data
    printf("  \"bumper_a_pressed\": %s,\n", bumper_pressed ? "true" : "false");

    // Gyro Data
    printf("  \"gyro_heading_deg_int\": %d,\n", gyro_heading_int);
    printf("  \"gyro_heading_deg_frac\": %d,\n", gyro_heading_frac);
    printf("  \"gyro_rate_dps_int\": %d,\n", gyro_rate_int);
    printf("  \"gyro_rate_dps_frac\": %d,\n", gyro_rate_frac);

    // Color Sensor Data
    printf("  \"color_hue\": %d,\n", color_hue);
    printf("  \"color_brightness_pct\": %d,\n", color_brightness);
    printf("  \"color_near_object\": %s,\n", color_near ? "true" : "false");

    // Touch LED Data
    printf("  \"touchled_r_pressed\": %s,\n", touchled_pressed ? "true" : "false");

    // Motor Encoder Data
    printf("  \"motor_left_pos_deg_int\": %d,\n", motor_pos_deg_int);
    printf("  \"motor_left_pos_deg_frac\": %d,\n", motor_pos_deg_frac);
    printf("  \"motor_left_vel_rpm_int\": %d,\n", motor_vel_rpm_int);
    printf("  \"motor_left_vel_rpm_frac\": %d,\n", motor_vel_rpm_frac);

    // Controller Data (LAST PAIR - NO COMMA)
    printf("  \"controller_axis_a\": %d,\n", axisA_value);
    printf("  \"controller_button_x\": %s\n", buttonX_pressed ? "true" : "false"); // NO COMMA HERE

    printf("}\n"); // End JSON object
}

int main() {
    char inputBuffer[50]; // Buffer for received string
    int loopCounter = 0;

    float value = 0; // Variable to hold the float value from scanf

    Brain.Screen.setFont(monoM);
    // Brain.Screen.print("Polling Example (scanf blocks)");
    Brain.Screen.newLine();
    // printf("Polling Example (scanf still blocks)\n");
    // printf("-------------------------------------\n");
    // printf("Send 'forward' or 'stop' from Mac (with newline)\n");

    while (true) {
        // --- Part 1: Non-Blocking Robot Tasks ---
        // Code here runs on every loop iteration *before* checking serial.
        // Example: Read sensors, apply basic motor logic, update screen counter.
        loopCounter++;
        Brain.Screen.setCursor(3, 1); // Row 3, Col 1
        // Brain.Screen.clearLine(3); // Clear rest of the line

        // Example: Maybe check a bumper sensor
        // if (BumperA.pressing()) {
        //     // React to bumper press
        // }

        // printf("Loop %d - About to check for input...\n", loopCounter);

        // --- End Part 1 ---


        // --- Part 2: Attempting to Read Serial Input (BLOCKING) ---
        // THIS IS WHERE THE PROGRAM WILL PAUSE AND WAIT FOR INPUT
        // It's NOT true polling. We are just calling the blocking function.
        // We can't easily check *if* data is available first.

        // Get all the sensor data and send on serial por
        while (true) {
            double dist_mm = DistanceSensor.objectDistance(mm);
            bool dist_found = DistanceSensor.isObjectDetected();
            if (dist_found) {
                Brain.Screen.setCursor(2, 1);
                Brain.Screen.print("Distance: %f mm", dist_mm);

                int val_int_part = (int)dist_mm;
                int val_frac_part = (int)fabsf((dist_mm - val_int_part) * 100.0f);
                printf("{distance: %d.%02d mm\n, ", val_int_part, val_frac_part);
            } else {
                Brain.Screen.setCursor(2, 1);
                Brain.Screen.print("No object detected");
            }

            wait(500, msec);

        }




        // *** The program WILL BLOCK HERE until you send a string + newline from Mac ***
        int result_str = scanf("%s", inputBuffer); // Read string and float from input


        // Split on ":"
        char *command = strtok(inputBuffer, ":");
        char *param = strtok(NULL, ":");

        value = atof(param);

        if (result_str == 1) {
            // Input was received and successfully read as a string
            // printf("--> Received string: '%s'\n", inputBuffer);
            LeftDriveSmart.stop();
            RightDriveSmart.stop();
            LeftDriveSmart.setPosition(0, degrees);
            RightDriveSmart.setPosition(0, degrees);
            Brain.Screen.setCursor(5, 1);


            // Act on the received command
            if (strcmp(inputBuffer, "FORWARD") == 0) {
                Brain.Screen.print("Forward %f", value); ;
                LeftDriveSmart.spinToPosition(value * 18, degrees, false);
                RightDriveSmart.spinToPosition(value * 18, degrees, false);
            } else if (strcmp(inputBuffer, "BACKWARD") == 0) {
                Brain.Screen.print("Backward %f", value); ;
                LeftDriveSmart.spinToPosition(value * (-18), degrees, false);
                RightDriveSmart.spinToPosition(value * (-18), degrees, false);
            } else if (strcmp(inputBuffer, "TURN") == 0) {
                // Angle is in degrees from -180 to 180
                Brain.Screen.setCursor(5, 1);
                if (value > 0) {
                    Brain.Screen.print("Turn Right %f", value);
                    LeftDriveSmart.spinToPosition(value * 2.29, degrees, false);
                    RightDriveSmart.spinToPosition(value * (-2.29), degrees, false);
                } else {
                    Brain.Screen.print("Turn Left %f", value);
                    LeftDriveSmart.spinToPosition(value * (-2.29), degrees, false);
                    RightDriveSmart.spinToPosition(value * 2.29, degrees, false);
                }

            } else if (strcmp(inputBuffer, "GRABBAR_HEIGHT") == 0) {
                

            } else if (strcmp(inputBuffer, "GRABBER_WIDTH") == 0) {

            }
             // Clear buffer for next read attempt by reading until newline (risky, might block more)
             // while(getchar() != '\n' && getchar() != EOF);

        } else {
            // printf("scanf result: %d. No valid string input received or stream error.\n", result_str);
        }
        // --- End Part 2 ---


        // --- Part 3: Other tasks (only run AFTER scanf completes/returns) ---
        // printf("...Finished input check for loop %d.\n", loopCounter);


        // --- Loop Delay ---
        // Wait a bit before the *next* loop iteration.
        // This delay happens *after* the scanf block resolves.
        wait(50, msec);
    }
}